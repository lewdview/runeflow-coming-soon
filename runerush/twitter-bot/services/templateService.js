const fs = require('fs').promises;\nconst path = require('path');\nconst crypto = require('crypto');\n\nclass TemplateService {\n    constructor(database) {\n        this.db = database;\n        this.templatesCache = null;\n        this.manifestPath = path.join(__dirname, '../../templates/runeflow_complete_vault_manifest.json');\n    }\n\n    /**\n     * Load templates from the manifest file\n     */\n    async loadTemplates() {\n        if (this.templatesCache) {\n            return this.templatesCache;\n        }\n\n        try {\n            const manifestData = await fs.readFile(this.manifestPath, 'utf8');\n            const manifest = JSON.parse(manifestData);\n            this.templatesCache = manifest.templates;\n            console.log(`âœ… Loaded ${this.templatesCache.length} templates from manifest`);\n            return this.templatesCache;\n        } catch (error) {\n            console.error('Error loading templates:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Initialize the template queue from the manifest\n     */\n    async initializeTemplateQueue() {\n        const templates = await this.loadTemplates();\n        \n        console.log('Initializing template queue...');\n        \n        for (const template of templates) {\n            try {\n                // Check if template already exists in queue\n                const existingTemplate = await this.db.query(\n                    'SELECT id FROM template_queue WHERE template_id = $1',\n                    [template.template_id]\n                );\n\n                if (existingTemplate.rows.length === 0) {\n                    // Calculate priority score based on quality and node count\n                    const priorityScore = this.calculatePriorityScore(template);\n                    \n                    await this.db.query(`\n                        INSERT INTO template_queue (\n                            template_id, template_name, template_category, \n                            nodes_count, quality_score, priority_score, is_active\n                        ) VALUES ($1, $2, $3, $4, $5, $6, $7)\n                    `, [\n                        template.template_id,\n                        template.template_name,\n                        template.category,\n                        template.nodes_count,\n                        template.quality_score,\n                        priorityScore,\n                        true\n                    ]);\n                }\n            } catch (error) {\n                console.error(`Error adding template ${template.template_id} to queue:`, error);\n            }\n        }\n        \n        console.log('âœ… Template queue initialized');\n    }\n\n    /**\n     * Calculate priority score for template selection\n     */\n    calculatePriorityScore(template) {\n        let score = 0;\n        \n        // Quality score weight (0-90 points)\n        score += (template.quality_score || 5) * 9;\n        \n        // Node count weight (more nodes = more complex/valuable, 0-20 points)\n        const nodeScore = Math.min((template.nodes_count || 10) / 5, 20);\n        score += nodeScore;\n        \n        // Category bonuses\n        const categoryBonus = {\n            'AI & Research': 15,\n            'Business Process': 12,\n            'Data Processing': 10,\n            'E-commerce': 12,\n            'Communication': 8,\n            'Marketing': 10\n        };\n        \n        score += categoryBonus[template.category] || 5;\n        \n        // Random factor to ensure variety (0-10 points)\n        score += Math.random() * 10;\n        \n        return Math.round(score);\n    }\n\n    /**\n     * Select the next template to post\n     */\n    async selectNextTemplate() {\n        try {\n            // Get template that hasn't been posted recently with highest priority\n            const result = await this.db.query(`\n                SELECT * FROM template_queue \n                WHERE is_active = true \n                AND (last_posted IS NULL OR last_posted < CURRENT_DATE - INTERVAL '30 days')\n                ORDER BY priority_score DESC, last_posted ASC NULLS FIRST, times_posted ASC\n                LIMIT 1\n            `);\n\n            if (result.rows.length === 0) {\n                // If no templates available, reset all templates (start over)\n                console.log('No available templates, resetting rotation...');\n                await this.resetTemplateRotation();\n                return this.selectNextTemplate();\n            }\n\n            const selectedTemplate = result.rows[0];\n            console.log(`ðŸ“‹ Selected template: ${selectedTemplate.template_name}`);\n            \n            return selectedTemplate;\n        } catch (error) {\n            console.error('Error selecting next template:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Reset template rotation (allow all templates to be posted again)\n     */\n    async resetTemplateRotation() {\n        try {\n            await this.db.query(`\n                UPDATE template_queue \n                SET last_posted = NULL \n                WHERE last_posted IS NOT NULL\n            `);\n            console.log('âœ… Template rotation reset');\n        } catch (error) {\n            console.error('Error resetting template rotation:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Mark a template as posted\n     */\n    async markTemplateAsPosted(templateId) {\n        try {\n            await this.db.query(`\n                UPDATE template_queue \n                SET last_posted = CURRENT_DATE, \n                    times_posted = times_posted + 1\n                WHERE template_id = $1\n            `, [templateId]);\n            \n            console.log(`âœ… Marked template ${templateId} as posted`);\n        } catch (error) {\n            console.error('Error marking template as posted:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Generate a unique access token for daily template access\n     */\n    generateAccessToken() {\n        return crypto.randomBytes(16).toString('hex');\n    }\n\n    /**\n     * Create a daily template record with access token\n     */\n    async createDailyTemplate(templateData, tweetData) {\n        const accessToken = this.generateAccessToken();\n        const expiresAt = new Date();\n        expiresAt.setHours(23, 59, 59, 999); // Expires at end of day\n        \n        try {\n            const result = await this.db.query(`\n                INSERT INTO daily_templates (\n                    template_id, template_name, template_category, nodes_count, quality_score,\n                    post_date, tweet_id, tweet_text, access_token, access_expires_at\n                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n                RETURNING id\n            `, [\n                templateData.template_id,\n                templateData.template_name,\n                templateData.template_category,\n                templateData.nodes_count,\n                templateData.quality_score,\n                new Date().toISOString().split('T')[0], // Today's date\n                tweetData.tweetId,\n                tweetData.tweetText,\n                accessToken,\n                expiresAt\n            ]);\n\n            const dailyTemplateId = result.rows[0].id;\n\n            // Create access token record\n            await this.db.query(`\n                INSERT INTO template_access_tokens (\n                    token, template_id, daily_template_id, expires_at\n                ) VALUES ($1, $2, $3, $4)\n            `, [\n                accessToken,\n                templateData.template_id,\n                dailyTemplateId,\n                expiresAt\n            ]);\n\n            console.log(`âœ… Created daily template record with token: ${accessToken}`);\n            \n            return {\n                dailyTemplateId,\n                accessToken,\n                expiresAt\n            };\n        } catch (error) {\n            console.error('Error creating daily template record:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Validate and get template by access token\n     */\n    async getTemplateByToken(token) {\n        try {\n            const result = await this.db.query(`\n                SELECT dt.*, tat.downloads_count, tat.max_downloads, tat.is_active as token_active\n                FROM daily_templates dt\n                JOIN template_access_tokens tat ON dt.id = tat.daily_template_id\n                WHERE tat.token = $1 AND tat.expires_at > CURRENT_TIMESTAMP AND tat.is_active = true\n            `, [token]);\n\n            if (result.rows.length === 0) {\n                return null;\n            }\n\n            return result.rows[0];\n        } catch (error) {\n            console.error('Error getting template by token:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Increment download count for a token\n     */\n    async incrementDownloadCount(token) {\n        try {\n            const result = await this.db.query(`\n                UPDATE template_access_tokens \n                SET downloads_count = downloads_count + 1\n                WHERE token = $1 AND is_active = true\n                RETURNING downloads_count, max_downloads\n            `, [token]);\n\n            if (result.rows.length > 0) {\n                const { downloads_count, max_downloads } = result.rows[0];\n                \n                // Deactivate token if max downloads reached\n                if (downloads_count >= max_downloads) {\n                    await this.db.query(\n                        'UPDATE template_access_tokens SET is_active = false WHERE token = $1',\n                        [token]\n                    );\n                }\n\n                // Also update the daily template downloads count\n                await this.db.query(`\n                    UPDATE daily_templates \n                    SET downloads_count = downloads_count + 1\n                    WHERE access_token = $1\n                `, [token]);\n\n                return { downloads_count, max_downloads };\n            }\n            \n            return null;\n        } catch (error) {\n            console.error('Error incrementing download count:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Clean up expired tokens\n     */\n    async cleanupExpiredTokens() {\n        try {\n            const result = await this.db.query(`\n                UPDATE template_access_tokens \n                SET is_active = false \n                WHERE expires_at < CURRENT_TIMESTAMP AND is_active = true\n            `);\n            \n            if (result.rowCount > 0) {\n                console.log(`âœ… Cleaned up ${result.rowCount} expired tokens`);\n            }\n            \n            return result.rowCount;\n        } catch (error) {\n            console.error('Error cleaning up expired tokens:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get template statistics\n     */\n    async getTemplateStats() {\n        try {\n            const stats = await this.db.query(`\n                SELECT \n                    COUNT(*) as total_posted,\n                    SUM(downloads_count) as total_downloads,\n                    SUM(views_count) as total_views,\n                    SUM(likes_count) as total_likes,\n                    SUM(retweets_count) as total_retweets,\n                    AVG(quality_score) as avg_quality\n                FROM daily_templates\n                WHERE post_date >= CURRENT_DATE - INTERVAL '30 days'\n            `);\n\n            return stats.rows[0];\n        } catch (error) {\n            console.error('Error getting template stats:', error);\n            throw error;\n        }\n    }\n}\n\nmodule.exports = TemplateService;"
